<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>PowerPiggy 博客</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="title: Drools 6官方文档 4date: 2016-07-10 19:07:43
description: 学习drools6 顺便翻译，英语很不好，翻译的很慢第二部分 KIEKIE是Drools和JBPM的共享核心，它为构建、部署以及资源组织提供了统一的方法论以及统一的编程模型
4 KIE4.1 概述4.1.1 项目整体分析　　在Drools和JBPM整合过程中，最简单的组名为“D">
<meta property="og:type" content="article">
<meta property="og:title" content="PowerPiggy 博客">
<meta property="og:url" content="http://powerpiggy.github.io/2016/07/18/Drools6官方文档4/index.html">
<meta property="og:site_name" content="PowerPiggy 博客">
<meta property="og:description" content="title: Drools 6官方文档 4date: 2016-07-10 19:07:43
description: 学习drools6 顺便翻译，英语很不好，翻译的很慢第二部分 KIEKIE是Drools和JBPM的共享核心，它为构建、部署以及资源组织提供了统一的方法论以及统一的编程模型
4 KIE4.1 概述4.1.1 项目整体分析　　在Drools和JBPM整合过程中，最简单的组名为“D">
<meta property="og:image" content="https://cloud.githubusercontent.com/assets/4536249/16770907/3a0a1978-4881-11e6-849f-185c1413b847.png">
<meta property="og:image" content="https://cloud.githubusercontent.com/assets/4536249/16828227/6d66f8fa-49c0-11e6-9797-fb99c842490e.png">
<meta property="og:image" content="https://cloud.githubusercontent.com/assets/4536249/16828381/c59b8ddc-49c1-11e6-8b36-d61a17dd674c.png">
<meta property="og:image" content="https://cloud.githubusercontent.com/assets/4536249/16828744/41ad39ea-49c5-11e6-963e-3988a4688e0e.png">
<meta property="og:image" content="https://cloud.githubusercontent.com/assets/4536249/16830833/dca76c3c-49d3-11e6-99c3-c4b210658495.png">
<meta property="og:image" content="https://cloud.githubusercontent.com/assets/4536249/16843838/6ed1e1fa-4a15-11e6-9b70-013be1ec2077.png">
<meta property="og:image" content="https://cloud.githubusercontent.com/assets/4536249/16876470/8af4f0ea-4ad6-11e6-9430-53711d9d66ca.png">
<meta property="og:image" content="https://cloud.githubusercontent.com/assets/4536249/16876913/73db83c2-4ad8-11e6-8f21-2d39cadf8703.png">
<meta property="og:image" content="https://cloud.githubusercontent.com/assets/4536249/16893781/151e0272-4b75-11e6-9865-d371605de22b.png">
<meta property="og:image" content="https://cloud.githubusercontent.com/assets/4536249/16893816/26d90632-4b76-11e6-921e-9fbd8b5a561f.png">
<meta property="og:image" content="https://cloud.githubusercontent.com/assets/4536249/16893916/09f72d84-4b79-11e6-9017-bd05e0611340.png">
<meta property="og:image" content="https://cloud.githubusercontent.com/assets/4536249/16893954/1d729690-4b7a-11e6-8a96-0cf594f6c566.png">
<meta property="og:image" content="https://cloud.githubusercontent.com/assets/4536249/16893973/c34c53f8-4b7a-11e6-9284-4070e80dcda7.png">
<meta property="og:image" content="https://cloud.githubusercontent.com/assets/4536249/16876470/8af4f0ea-4ad6-11e6-9430-53711d9d66ca.png">
<meta property="og:image" content="https://cloud.githubusercontent.com/assets/4536249/16898033/d51451a6-4bf9-11e6-9d04-204fa37c912c.png">
<meta property="og:image" content="https://cloud.githubusercontent.com/assets/4536249/16876913/73db83c2-4ad8-11e6-8f21-2d39cadf8703.png">
<meta property="og:image" content="https://cloud.githubusercontent.com/assets/4536249/16898887/9d4cec62-4c1f-11e6-8e99-d9c161bc3b20.png">
<meta property="og:image" content="https://cloud.githubusercontent.com/assets/4536249/16899406/2321cc80-4c35-11e6-9bb6-8c43edd1f276.png">
<meta property="og:image" content="https://cloud.githubusercontent.com/assets/4536249/16899414/b9c257ae-4c35-11e6-8aef-855e861f4226.png">
<meta property="og:image" content="https://cloud.githubusercontent.com/assets/4536249/16899510/6a2228f6-4c39-11e6-8ee1-2cec4110828b.png">
<meta property="og:image" content="https://cloud.githubusercontent.com/assets/4536249/16899557/16277f1a-4c3b-11e6-80a3-00b495b3c182.png">
<meta property="og:image" content="https://cloud.githubusercontent.com/assets/4536249/16899626/330c4e88-4c3d-11e6-9140-bd5074af037d.png">
<meta property="og:image" content="https://cloud.githubusercontent.com/assets/4536249/16899632/5da870d6-4c3d-11e6-9472-034e65238d75.png">
<meta property="og:image" content="https://cloud.githubusercontent.com/assets/4536249/16904948/5b246b14-4cd1-11e6-96a9-d7b80c547cd5.png">
<meta property="og:image" content="https://cloud.githubusercontent.com/assets/4536249/16905352/52aea3ea-4cd7-11e6-95c2-dab92a026533.png">
<meta property="og:image" content="https://cloud.githubusercontent.com/assets/4536249/16910921/1132c676-4d0e-11e6-8a11-c8a55f6db262.png">
<meta property="og:image" content="https://cloud.githubusercontent.com/assets/4536249/16910928/19fc5006-4d0e-11e6-8103-0bab5abeccc5.png">
<meta property="og:updated_time" content="2016-07-24T14:29:26.180Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="PowerPiggy 博客">
<meta name="twitter:description" content="title: Drools 6官方文档 4date: 2016-07-10 19:07:43
description: 学习drools6 顺便翻译，英语很不好，翻译的很慢第二部分 KIEKIE是Drools和JBPM的共享核心，它为构建、部署以及资源组织提供了统一的方法论以及统一的编程模型
4 KIE4.1 概述4.1.1 项目整体分析　　在Drools和JBPM整合过程中，最简单的组名为“D">
<meta name="twitter:image" content="https://cloud.githubusercontent.com/assets/4536249/16770907/3a0a1978-4881-11e6-849f-185c1413b847.png">
  
    <link rel="alternate" href="/atom.xml" title="PowerPiggy 博客" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
  

</head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">PowerPiggy 博客</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" results="0" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://powerpiggy.github.io"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main"><article id="post-Drools6官方文档4" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/07/18/Drools6官方文档4/" class="article-date">
  <time datetime="2016-07-18T10:55:08.279Z" itemprop="datePublished">2016-07-18</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="article-entry" itemprop="articleBody">
      
        <hr>
<p>title: Drools 6官方文档 4<br>date: 2016-07-10 19:07:43</p>
<h2 id="description-学习drools6-顺便翻译，英语很不好，翻译的很慢"><a href="#description-学习drools6-顺便翻译，英语很不好，翻译的很慢" class="headerlink" title="description: 学习drools6 顺便翻译，英语很不好，翻译的很慢"></a>description: 学习drools6 顺便翻译，英语很不好，翻译的很慢</h2><h1 id="第二部分-KIE"><a href="#第二部分-KIE" class="headerlink" title="第二部分 KIE"></a>第二部分 KIE</h1><p>KIE是Drools和JBPM的共享核心，它为构建、部署以及资源组织提供了统一的方法论以及统一的编程模型</p>
<h2 id="4-KIE"><a href="#4-KIE" class="headerlink" title="4 KIE"></a>4 KIE</h2><h3 id="4-1-概述"><a href="#4-1-概述" class="headerlink" title="4.1 概述"></a>4.1 概述</h3><h4 id="4-1-1-项目整体分析"><a href="#4-1-1-项目整体分析" class="headerlink" title="4.1.1 项目整体分析"></a>4.1.1 项目整体分析</h4><p>　　在Drools和JBPM整合过程中，最简单的组名为“DroolsJbpm”，但是为了满足更大项目的需要，组项目名称定义为KIE，即Knowledge Is Everything（知识就是一切），KIE也被用作系统的其他公共部分，包括统一构建、部署、以及运行。</p>
<p>　　目前KIE包括如下子项目。</p>
<p><img src="https://cloud.githubusercontent.com/assets/4536249/16770907/3a0a1978-4881-11e6-849f-185c1413b847.png" alt=""></p>
<p>　　OptaPlanner，本地搜索和优化工具，已经从Drools的Planner分拆出来，成为与Drools和jBPM并列的一个顶级项目。OptaPlanner独立发展与进化，虽然与Drools有较强的整合能力，但已经不依赖于Drools。</p>
<p>　　通过对Polymita的收购，获得了功能强大的Dashboard Builder（仪表盘生成器？），Dashboard Builder可以提供强大的报表功能，Dashboard Builder是一个临时的名称，在６.0版本之后，会选择一个新的名称。Dashboard Builder完全独立于Drools和Jbpm，在JBoss的很多项目中都有使用，也希望用于其它非JBoss项目。</p>
<p>　　UberFire是从头编写的全新的工作台基础项目， UberFire提供了Eclipse的工作台类似的功能，提供插件板和视角等功能。该项目与Drools和jBPM保持独立，任何人都可以使用它构建灵活和强大的工作台。 Jboss将使用UberFire构建各种系统的控制台和工作台。</p>
<p>　　使用Guvnor（雇主、老板）名称透露了很多对此项目的预期，比如决策表，应该是Guvnor组件而不是Drools的组件，与５.ｘGuvnor的单一项目结构不同，Guvnor　６.０Guvnor聚焦于整合一组UberFire插件，以提供构建基于Web的IDE基础，比如内嵌Maven用于构建与发布、管理Maven仓库，以及活动提醒等（activity notifications via inboxes），Drools与Jbpm工作台使用UberFire作为基础，包括一整套插件，包括Guvnor，以及他们（Drools与Jbpm）各自的插件，例如决策表、guided editors、BPMN2编辑器、人工任务（hunman tasks）。Drools的工作台称为Drools-WB，而KIE-WB是统一工作台，整合了Guvnor、Drools、以及JPBM的插件，在图中的JBPM-WB并不存在，只是为了便于概念上的表达而出现在图中。</p>
<h4 id="4-1-2-生命周期"><a href="#4-1-2-生命周期" class="headerlink" title="4.1.2 生命周期"></a>4.1.2 生命周期</h4><p>　　KIE系统的不同方面，例如Drools和JBPM，知识拥有类似的生命周期，生命周期可以分为以下几个阶段：</p>
<p>　　编写：<br>　　使用各种UI工具进行知识进行编写，这里包括DRL（规则），BPMN2（流程）、决策表、对象模型等。</p>
<p>　　构建：<br>　　将编写阶段生成的知识信息编译成可以发布的单元，在KIE系统中可发布单元为JAR文件。</p>
<p>　　测试：<br>　　在发布前，对KIE知识进行测试。</p>
<p>　　发布阶段：<br>　　将KIE知识发布到仓库中，是应用程序可以加载，KIE系统使用类似Maven仓库进行发布。</p>
<p>　　加载：<br>　　应用程序使用KEI　Session（KieSession）加载已经发布的KIE知识。</p>
<p>　　KIE使用KIE container(KieContainer)引出JAR（知识JAR）运行时。KieSession是由KieContainer创建与知识运行时进行交互的。</p>
<p>　　运行：<br>　　系统使用API与KieSession进行交互。</p>
<p>　　管理：<br>　　管理KieSession和KieContainer。</p>
<h3 id="4-2-构建、发布、加载和运行"><a href="#4-2-构建、发布、加载和运行" class="headerlink" title="4.2 构建、发布、加载和运行"></a>4.2 构建、发布、加载和运行</h3><h4 id="4-2-1-介绍"><a href="#4-2-1-介绍" class="headerlink" title="4.2.1 介绍"></a>4.2.1 介绍</h4><p>　　６.0引入一套新的基于配置和约定的方法来建立知识的基础，而不是使用5.x编写程序的方法，而且知识的生成器可以用于工具的集成。</p>
<p>　　构建使用Maven方式，一个KIE的项目或模块就是简单的Maven java项目和模块，只不过是增加了元数据文件META-INF/kmodule.xml,The kmodule.xml file is the descriptor that selects resources to knowledge bases and configures those knowledge bases and sessions. There is also alternative XML support via Spring and OSGi BluePrints.?</p>
<p>　　虽然标准 Maven 可以构建和打包桂金资源，它不会提供生成时验证。还有一个 Maven 插件建议使用，来获取生成时间验证。该插件还会生成很多类，使运行时更快地加载。</p>
<p>　　下面的屏幕截图是一个例子项目的项目结构以及Maven　POM描述。</p>
<p><img src="https://cloud.githubusercontent.com/assets/4536249/16828227/6d66f8fa-49c0-11e6-9797-fb99c842490e.png" alt=""></p>
<p>　　KIE通过提供默认值的方式，来最小化配置，空的kmodule.xml就是最小化的配置，但是即便为空，kmodule.xml也必须存在，因为它被用来发现KIE类型的JAR及其内容。</p>
<p>　　在Maven中可以使用“mvn install”将KIE模块安装于本地，在这台机器上的所有相关程序就可以使用它，也可以使用Maven 将KIE模块推送至远程Maven仓库，这样其他应用可以将其拉至本地仓库，并使用它。</p>
<p>　　Maven流程如下：</p>
<p><img src="https://cloud.githubusercontent.com/assets/4536249/16828381/c59b8ddc-49c1-11e6-8b36-d61a17dd674c.png" alt=""> </p>
<p>　　部署知识Jar有两种方式，一是静态方式，与其他的Jar类似，使用Maven的依赖列表，二是使用在运行时动态加载。KIE会自动扫描类路径，找到所有包括kmodule.xml的Jar包，每个找到的知识Jar将被一个KieModule接口所表示， 这两种方式被分别称为classpath KieModule和dynamic KieModule ，dynamic KieModule支持版本控制（同一jar的不同版本），并可以同时使用，而classpath KieModule不支持这种方式，一旦一个Module的某一版本使用classpath KieModule加载之后，这个Module的其他版本就无法加载了。</p>
<p>　　详细的API包括于下节内容中，着急的可以直接调制示例章节。</p>
<h4 id="4-2-2-构建"><a href="#4-2-2-构建" class="headerlink" title="4.2.2 构建"></a>4.2.2 构建</h4><p><img src="https://cloud.githubusercontent.com/assets/4536249/16828744/41ad39ea-49c5-11e6-963e-3988a4688e0e.png" alt=""></p>
<h5 id="4-2-2-1-创建和构建Kie项目"><a href="#4-2-2-1-创建和构建Kie项目" class="headerlink" title="4.2.2.1 创建和构建Kie项目"></a>4.2.2.1 创建和构建Kie项目</h5><p>　　Kie项目与标准的Maven项目结构相同，唯一的特点是添加了kmodule.xml文件，用以用声明的方法定义从这个项目可以创建的KieBases 和 KieSessions，这个文件放置在resources/META-INF 目录下，Kie其他的相关文件，比如DRL或Excel文件必须放在resources目录或其子目录中。</p>
<p>　　由于所有的配置项都提供了默认值，所以kmodule.xml可以为空，只包含如下文件头即可。</p>
<pre><code>Example 4.1. An empty kmodule.xml file

&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;kmodule xmlns=&quot;http://www.drools.org/xsd/kmodule&quot;/&gt;
</code></pre><p>　　以这种方式的 kmodule 将包含一个单个默认 KieBase。所有的Kie资源都存储在resources目录或子目录，并且会编译进Jar文件，在此基础上，就可以创建KieContainer。</p>
<p><img src="https://cloud.githubusercontent.com/assets/4536249/16830833/dca76c3c-49d3-11e6-99c3-c4b210658495.png" alt=""></p>
<p>　　上面简单的配置已经可以用来创建KieContainer。</p>
<pre><code>Example 4.2. Creating a KieContainer from the classpath

KieServices kieServices = KieServices.Factory.get();
KieContainer kContainer = kieServices.getKieClasspathContainer();
</code></pre><p>　　KieServices　是访问所有Kie　对象及运行时的接口。<br><img src="https://cloud.githubusercontent.com/assets/4536249/16843838/6ed1e1fa-4a15-11e6-9b70-013be1ec2077.png" alt=""></p>
<p>　　使用这种方式，使得Java源码以及Kie资源全部打包发布到KieContainer中，使其内容可以在运行时使用。</p>
<h5 id="4-2-2-2-kmodule-xml-文件"><a href="#4-2-2-2-kmodule-xml-文件" class="headerlink" title="4.2.2.2 kmodule.xml 文件"></a>4.2.2.2 kmodule.xml 文件</h5><p>　　就像上面的章节描述的，kmodule.xml是KIE项目用来以声明方式配置KieBase和KieSession的地方。</p>
<p>　　特别是KieBase是应用程序存放知识定义的仓库，它包含规则、过程、函数以及类型模型。但是KieBase并不存放数据，相反session由KieBase创建出来，用于插入数据，并可能启动流程实例。创建KieBase是比较重量级的，而session比较轻量，所以建议如果session需要不断重复创建时，需要缓存相关的KieBase，当然最终用户不用担心这个问题，这种缓存机制已经由KieContainer自动提供了。</p>
<p><img src="https://cloud.githubusercontent.com/assets/4536249/16876470/8af4f0ea-4ad6-11e6-9430-53711d9d66ca.png" alt=""></p>
<p>　　相反KieSession存储运行时数据，它可以由KieBase创建，更简单的方法是由KieContainer直接创建，前提是需要先在kmoudule.xml中定义它。</p>
<p><img src="https://cloud.githubusercontent.com/assets/4536249/16876913/73db83c2-4ad8-11e6-8f21-2d39cadf8703.png" alt=""></p>
<p>　　Kmodule.xml 允许定义和配置一个或多个 KieBases，每个 KieBase 可以创建不同的KieSessions，下面是Kmodule.xml的例子。</p>
<pre><code>Example 4.3. A sample kmodule.xml file

&lt;kmodule xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;   xmlns=&quot;http://www.drools.org/xsd/kmodule&quot;&gt;
  &lt;configuration&gt;
    &lt;property key=&quot;drools.evaluator.supersetOf&quot; value=&quot;org.mycompany.SupersetOfEvaluatorDefinition&quot;/&gt;
  &lt;/configuration&gt;
  &lt;kbase name=&quot;KBase1&quot; default=&quot;true&quot; eventProcessingMode=&quot;cloud&quot; equalsBehavior=&quot;equality&quot; declarativeAgenda=&quot;enabled&quot; packages=&quot;org.domain.pkg1&quot;&gt;
    &lt;ksession name=&quot;KSession2_1&quot; type=&quot;stateful&quot; default=&quot;true&quot;/&gt;
    &lt;ksession name=&quot;KSession2_2&quot; type=&quot;stateless&quot; default=&quot;false&quot; beliefSystem=&quot;jtms&quot;/&gt;
  &lt;/kbase&gt;
  &lt;kbase name=&quot;KBase2&quot; default=&quot;false&quot; eventProcessingMode=&quot;stream&quot; equalsBehavior=&quot;equality&quot; declarativeAgenda=&quot;enabled&quot; packages=&quot;org.domain.pkg2, org.domain.pkg3&quot; includes=&quot;KBase1&quot;&gt;
    &lt;ksession name=&quot;KSession3_1&quot; type=&quot;stateful&quot; default=&quot;false&quot; clockType=&quot;realtime&quot;&gt;
        &lt;fileLogger file=&quot;drools.log&quot; threaded=&quot;true&quot; interval=&quot;10&quot;/&gt;
        &lt;workItemHandlers&gt;
          &lt;workItemHandler name=&quot;name&quot; type=&quot;org.domain.WorkItemHandler&quot;/&gt;
        &lt;/workItemHandlers&gt;
        &lt;listeners&gt;
          &lt;ruleRuntimeEventListener type=&quot;org.domain.RuleRuntimeListener&quot;/&gt;
          &lt;agendaEventListener type=&quot;org.domain.FirstAgendaListener&quot;/&gt;
          &lt;agendaEventListener type=&quot;org.domain.SecondAgendaListener&quot;/&gt;
          &lt;processEventListener type=&quot;org.domain.ProcessListener&quot;/&gt;
        &lt;/listeners&gt;
    &lt;/ksession&gt;
  &lt;/kbase&gt;
&lt;/kmodule&gt;
</code></pre><p>　　上边的XML中<configuration>标签可选属性（键－值对的形式），这些属性用来配置KieBase的构建过程。例如这个简单的Kmodule.xml定义附加的自定义操作supersetOf，这个自定义操作由org.mycompany.SupersetOfEvaluatorDefinition实现。然后是两个kbase定义，第一个中又定义了两个类型的KieSession，而第二个KieBase只定义了一个KieSession，KieBase可以定义属性列表，这些属性的意义及默认值请见下表。</configuration></p>
<p>　　表４.1 kbase属性。</p>
<table>
<thead>
<tr>
<th>属性名称</th>
<th style="text-align:center">默认值</th>
<th style="text-align:center">可接受的值</th>
<th style="text-align:center">含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>name</td>
<td style="text-align:center">none</td>
<td style="text-align:center">any</td>
<td style="text-align:center">KieBase的名称，唯一的必填字段</td>
</tr>
<tr>
<td>includes</td>
<td style="text-align:center">none</td>
<td style="text-align:center">any comma separated list</td>
<td style="text-align:center">这个Kmodule所包含的其他的kbase列表，kbase名称由逗号分开， 这些kbase的构件也会被这个kbase所包含</td>
</tr>
<tr>
<td>packages</td>
<td style="text-align:center">all</td>
<td style="text-align:center">any comma separated list</td>
<td style="text-align:center">缺省状态下，Drools的构件在resources 目录下，包括子目录属于kbase，这个属性可以限制那些资源可以编译进kbase，资源列表是用逗号隔开的列表</td>
</tr>
<tr>
<td>default</td>
<td style="text-align:center">false</td>
<td style="text-align:center">true,false</td>
<td style="text-align:center">定义这个kbase是所在模块的缺省值，这个Kbase可以用KieContainer创建，而不需要提供名称，一个模块只能有一个缺省kbase</td>
</tr>
<tr>
<td>equalsBehavior</td>
<td style="text-align:center">identity</td>
<td style="text-align:center">identity, equality</td>
<td style="text-align:center">定义当一个新的fact插入到工作内存中的不同方式， identity 方式总是创建新的FactHandle，除非相同的对象已经不在工作内存中，equality方式仅仅在当前需要插入的对象不等于已经存在的fact时，创建新的FactHandle</td>
</tr>
<tr>
<td>eventProcessingMode</td>
<td style="text-align:center">cloud</td>
<td style="text-align:center">cloud, stream</td>
<td style="text-align:center">当cloud方式时，Kibase使用普通fact方式对待事件（event），while in stream mode allow temporal reasoning on them.</td>
</tr>
<tr>
<td>declarativeAgenda</td>
<td style="text-align:center">disabled</td>
<td style="text-align:center">disabled, enabled</td>
<td style="text-align:center">Defines if the Declarative Agenda is enabled or not.</td>
</tr>
</tbody>
</table>
<p>　　类似的标签ksession的属性也都有默认值（除了名称以外），这些属性在下面的列表中描述。</p>
<p>　　表４.２ ksesson属性。</p>
<table>
<thead>
<tr>
<th>属性名称</th>
<th style="text-align:center">默认值</th>
<th style="text-align:center">可接受的值</th>
<th style="text-align:center">含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>name</td>
<td style="text-align:center">none</td>
<td style="text-align:center">any</td>
<td style="text-align:center">kssion的名称，不能重复，唯一的必填属性</td>
</tr>
<tr>
<td>type</td>
<td style="text-align:center">stateful</td>
<td style="text-align:center">stateful, stateless</td>
<td style="text-align:center">stateful 是有状态的session，拥有工作内存，允许迭代执行，stateless是指无状态session，使用提供的数据集在工作内存中一次执行</td>
</tr>
<tr>
<td>default</td>
<td style="text-align:center">false</td>
<td style="text-align:center">true,false</td>
<td style="text-align:center">定义这个ksession是否是所在模块的缺省ksession，如果是缺省ksession，则可以使用KieContainer创建，而不需要提供名称，在一个模块中只能有一个缺省ksession</td>
</tr>
<tr>
<td>clockType</td>
<td style="text-align:center">realtime</td>
<td style="text-align:center">realtime, pseudo</td>
<td style="text-align:center">设置事件的时间戳是系统时间（realtime）还是由程序控制的伪时间（pseudo），伪时间常常用于测试与时间相关的规则</td>
</tr>
<tr>
<td>beliefSystem</td>
<td style="text-align:center">simple</td>
<td style="text-align:center">simple, jtms, defeasible</td>
<td style="text-align:center">Defines the type of belief system used by the KieSession.</td>
</tr>
</tbody>
</table>
<p>　　如上面的KModule.xml例子所示，可以为每一个KieSession声明创建一个文件（或控制台）日志，一个或多个workItemHandler，以及多个监听器，这些监听器分为三个类型，分别是ruleRuntimeEventListener，agendaEventListener和processEventListener</p>
<p>　　如上面的KModule.xml例子所示，可以使用名称在KieContainer中检索KieBases和KieSessions。</p>
<pre><code>Example 4.4. Retriving KieBases and KieSessions from the KieContainer

KieServices kieServices = KieServices.Factory.get();
KieContainer kContainer = kieServices.getKieClasspathContainer();

KieBase kBase1 = kContainer.getKieBase(&quot;KBase1&quot;);
KieSession kieSession1 = kContainer.newKieSession(&quot;KSession2_1&quot;);
StatelessKieSession kieSession2 = kContainer.newStatelessKieSession(&quot;KSession2_2&quot;);
</code></pre><p>　　这里需要指出的是，由于 KSession2_1 和 KSession2_2 是两种不同类型 （第一个是有状态，而第二个是无状态的），需要根据类型的不同调用KieContainer的两个不同的方法，如果需要的KieSession类型与KModule.xml中定义的不一致，KieContainer将甩出运行时异常，另外因为设置了缺省的KieBase和KieSession，所以可以通过KieContainer使用不传递名称的方法，获取缺省的KieBase和KieSession。</p>
<pre><code>Example 4.5. Retriving default KieBases and KieSessions from the KieContainer

KieContainer kContainer = ...

KieBase kBase1 = kContainer.getKieBase(); // returns KBase1
KieSession kieSession1 = kContainer.newKieSession(); // returns KSession2_1
</code></pre><p>　　另外Kie项目也是Maven项目，所以可以通过Pom文件中的groupId, artifactId 和 version生成唯一ID　ReleaseId，然后将ReleaseId直接传递给KieServices即可以创建KieContainer。</p>
<pre><code>Example 4.6. Creating a KieContainer of an existing project by ReleaseId

KieServices kieServices = KieServices.Factory.get();
ReleaseId releaseId = kieServices.newReleaseId( &quot;org.acme&quot;, &quot;myartifact&quot;, &quot;1.0&quot; );
KieContainer kieContainer = kieServices.newKieContainer( releaseId );
</code></pre><h5 id="4-2-2-3-使用Maven构建"><a href="#4-2-2-3-使用Maven构建" class="headerlink" title="4.2.2.3 使用Maven构建"></a>4.2.2.3 使用Maven构建</h5><p>　　Kie的Maven插件用来对项目的构件资源进行验证及与预编译，建议在始终使用此插件，使用此插件只需要在Maven的Pom文件的Build部分添加如下内容，并且使用packaging kjar来激活此配置。</p>
<pre><code>&lt;packaging&gt;kjar&lt;/packaging&gt;
 ...
 &lt;build&gt;
   &lt;plugins&gt;
     &lt;plugin&gt;
       &lt;groupId&gt;org.kie&lt;/groupId&gt;
       &lt;artifactId&gt;kie-maven-plugin&lt;/artifactId&gt;
       &lt;version&gt;6.4.0.Final&lt;/version&gt;
       &lt;extensions&gt;true&lt;/extensions&gt;
     &lt;/plugin&gt;
   &lt;/plugins&gt;
 &lt;/build&gt;    
</code></pre><p>　　这个插件可以支持支持所有 Drools/jBPM 知识资源。但是如果你的Java类上使用了KIE的注释，比如@kie.api.Position，你需要在在你的项目中添加编译时依赖 kie-api，我们建议为所有添加的KIE依赖使用provided scope ，这样Kjar可以保持尽量轻量，而且不依赖于特定版本的KIE。</p>
<p>　　不使用Maven进行构建时，需要拷贝所有的资源到结果JAR中，当这个JAR被加载是，会试着编译这些资源，一旦存在编译错误，则会返回一个空的KieContainer，而且这样会带来运行时编译所额外的开销，所以不建议这样做，应该尽量使用Maven插件进行构建。</p>
<h5 id="4-2-2-4-使用程序定义KieModule"><a href="#4-2-2-4-使用程序定义KieModule" class="headerlink" title="4.2.2.4 使用程序定义KieModule"></a>4.2.2.4 使用程序定义KieModule</h5><p>　　也可以使用编程的方式在KieModule中定义KieBase和KieSession，相同的编程API可以显式地添加包含Kie构件的文件，而不是从resources目录中读取。需要做的这一点，需要创建KieFileSystem，这是一个虚拟文件系统，可以把你项目中的资源全部添加给它。<br><img src="https://cloud.githubusercontent.com/assets/4536249/16893781/151e0272-4b75-11e6-9865-d371605de22b.png" alt=""></p>
<p>　　就像其他的核心组件，你可以从KieService获取KieFileSystem，Kｍodule.xml配置文件必须添加到文件系统，这是必须的一步，Kie提供流行的流式API，叫做KieModuleModel，用于以编程方式创建配置文件。</p>
<p><img src="https://cloud.githubusercontent.com/assets/4536249/16893816/26d90632-4b76-11e6-921e-9fbd8b5a561f.png" alt=""></p>
<p>　　做到这一点必须从KieServices 创建 KieModuleModel，配置所需的 KieBases 与 KieSessions、 转换 XML 中并将 XML 添加到 KieFileSystem。这一过程是由下面的示例所示︰</p>
<pre><code>Example 4.8. Creating a kmodule.xml programmatically and adding it to a KieFileSystem

KieServices kieServices = KieServices.Factory.get();
KieModuleModel kieModuleModel = kieServices.newKieModuleModel();

KieBaseModel kieBaseModel1 = kieModuleModel.newKieBaseModel( &quot;KBase1 &quot;)
.setDefault( true )
.setEqualsBehavior( EqualityBehaviorOption.EQUALITY )
.setEventProcessingMode( EventProcessingOption.STREAM );

KieSessionModel ksessionModel1 = kieBaseModel1.newKieSessionModel( &quot;KSession1&quot; )
.setDefault( true )
.setType( KieSessionModel.KieSessionType.STATEFUL )
.setClockType( ClockTypeOption.get(&quot;realtime&quot;) );

KieFileSystem kfs = kieServices.newKieFileSystem();
kfs.writeKModuleXML(kieModuleModel.toXML());
</code></pre><p>　　其他的组成你的项目的构件，也必须添加到KieFileSystem中，这可以使用KieFileSystem的流式API,这些构件必须与Maven方式添加的构件有相同的位置。　　</p>
<pre><code>Example 4.9. Adding Kie artifacts to a KieFileSystem

KieFileSystem kfs = ...
kfs.write( &quot;src/main/resources/KBase1/ruleSet1.drl&quot;, stringContainingAValidDRL )
.write( &quot;src/main/resources/dtable.xls&quot;,
kieServices.getResources().newInputStreamResource( dtableFileStream ) );
</code></pre><p>　　这个例子表明可以使用字符串或资源方式添加Kie构件，添加资源时，资源可以用KieService提供的KieResource工厂创建，KieResource提供许多方便的工厂方法，可以将InputStream、URL、文件或文件系统路径字符串转换成KieFileSystem可以管理的资源。</p>
<p><img src="https://cloud.githubusercontent.com/assets/4536249/16893916/09f72d84-4b79-11e6-9017-bd05e0611340.png" alt=""></p>
<p>　　一般来说，可以通过添加到KieFileSystem的资源名称扩展名来判断资源的类型，但是也有可能资源并不遵循Kie的扩展名的约定，所有添加资源的时候也可以显式地制定资源类型，比如下面的代码。</p>
<pre><code>Example 4.10. Creating and adding a Resource with an explicit type

KieFileSystem kfs = ...
kfs.write( &quot;src/main/resources/myDrl.txt&quot;,
   kieServices.getResources().newInputStreamResource( drlStream )
  .setResourceType(ResourceType.DRL) );
</code></pre><p>　　添加所有的资源到KieFileSystem，如果想构建它，则将KieFileSystem传递给KieBuilder。</p>
<p><img src="https://cloud.githubusercontent.com/assets/4536249/16893954/1d729690-4b7a-11e6-8a96-0cf594f6c566.png" alt=""></p>
<p>　　一旦KieFileSystem的内容被成功构建，构建结果KitModule就会被自动添加到KieRepository中，KieRepository是所有可用的KieModule的单一仓库。</p>
<p><img src="https://cloud.githubusercontent.com/assets/4536249/16893973/c34c53f8-4b7a-11e6-9284-4070e80dcda7.png" alt=""></p>
<p>　　在这之后，可以通过KieService使用ReleaseID为KieModule创建KieContainer，但是这种方式中KieFileSystem并不包含Pom.xml文件（可以通过KieFileSystem.writePomXML方法创建一个），Kie无法确定KieModule的ReleaseId，所以为其分配了一个默认的ReleaseId，这个ReleaseId可以从KieRepository获得，这个ReleaseId可以用于在这个KieRepository内部标识KieModule，下面的代码展示了这个过程。</p>
<pre><code>Example 4.11. Building the contents of a KieFileSystem and creating a KieContainer

KieServices kieServices = KieServices.Factory.get();
KieFileSystem kfs = ...
kieServices.newKieBuilder( kfs ).buildAll();
KieContainer kieContainer = kieServices.newKieContainer(kieServices.getRepository().getDefaultReleaseId());
</code></pre><p>　　在这个基础之上，就可以使用与从类路径直接创建的KieCOntainer的同样方法，获取KieBase或创建新的KieSession。</p>
<p>　　另外最好检查构建的结果，KieBuilder报告三种不同程度的编译信息，ERROR, WARNING and INFO，ERROR表示项目编译失败，而且没有产生KModule，并且什么也不添加到KieRepository，WARNING 和 INFO可以被忽略，但可供查阅。</p>
<pre><code>Example 4.12. Checking that a compilation didn&apos;t produce any error

KieBuilder kieBuilder = kieServices.newKieBuilder( kfs ).buildAll();
assertEquals( 0, kieBuilder.getResults().getMessages( Message.Level.ERROR ).size() );
</code></pre><h5 id="4-2-2-5-变更默认的构建信息的级别"><a href="#4-2-2-5-变更默认的构建信息的级别" class="headerlink" title="4.2.2.5 变更默认的构建信息的级别"></a>4.2.2.5 变更默认的构建信息的级别</h5><p>　　在某些情况下，可能需要变更默认的构建信息的级别，比如当一个新的规则添加到包中，但是此包中已经有一个同名的规则，默认的做法是旧的规则被新的规则所覆盖，并且产生的构建信息是INFO级别，这可能适用于绝大多数情况，但是在某些场景中，用户可能想阻止覆盖，并且构建信息的级别为ERROR。</p>
<p>　　可以想配置Drools其他选项一样改变构建信息级别，可以使用API调用、系统属性或配置文件来进行修改，在这个版本里Drools支持定义规则更新和功能更新的信息级别，可以使用系统属性和配置文件配置，用户可以使用下面的属性进行定义。</p>
<pre><code>Example 4.13. Setting the severity using properties

// sets the severity of rule updates
drools.kbuilder.severity.duplicateRule = &lt;INFO|WARNING|ERROR&gt;
// sets the severity of function updates
drools.kbuilder.severity.duplicateFunction = &lt;INFO|WARNING|ERROR&gt;
</code></pre><h4 id="4-2-3-发布"><a href="#4-2-3-发布" class="headerlink" title="4.2.3 发布"></a>4.2.3 发布</h4><h5 id="4-2-3-1-KieBase"><a href="#4-2-3-1-KieBase" class="headerlink" title="4.2.3.1 KieBase"></a>4.2.3.1 KieBase</h5><p>　　KieBase是应用程序存放知识定义的仓库，它包含规则、过程、函数以及类型模型。但是KieBase并不存放数据，相反session由KieBase创建出来，用于插入数据，并可能启动流程实例。KieBase可以从KieContainer中获取，前提是这个KieContainer包含定义这个KieBase的KieModule。</p>
<p><img src="https://cloud.githubusercontent.com/assets/4536249/16876470/8af4f0ea-4ad6-11e6-9430-53711d9d66ca.png" alt=""></p>
<p>　　在一些情况下，比如在OSGI环境中，KieBase需要解决类型不在默认的类加载器中，在这种情况下，需要创建拥有附加类加载器的KieBaseConfiguration，并将其传递给KieContainer，在从KeiContainer创建KieBase。</p>
<pre><code>Example 4.14. Creating a new KieBase with a custom ClassLoader

KieServices kieServices = KieServices.Factory.get();
KieBaseConfiguration kbaseConf = kieServices.newKieBaseConfiguration( null, MyType.class.getClassLoader() );
KieBase kbase = kieContainer.newKieBase( kbaseConf );
</code></pre><h5 id="4-2-3-2-KeiSession和KieBase的修改"><a href="#4-2-3-2-KeiSession和KieBase的修改" class="headerlink" title="4.2.3.2 KeiSession和KieBase的修改"></a>4.2.3.2 KeiSession和KieBase的修改</h5><p>　　KieSession会在“运行”的章节中详细讨论，KieBase创建和返回KieSession，它可以选择保持对这些KieSession的引用，当KieBase发生修改时，修改也会这些Session的数据上，这些引用是弱引用，而且是可选的，被一个boolean类型所控制。</p>
<h5 id="4-2-3-3-KieScanner"><a href="#4-2-3-3-KieScanner" class="headerlink" title="4.2.3.3 KieScanner"></a>4.2.3.3 KieScanner</h5><p>　　KieScanner可以持续观察你的Maven仓库，以检查是否有新的Release版本的Kie项目发布，新的Release可以部署到拥有KieContainer的项目中，使用KieScanner需要Kie-ci.jar在classpath中。<br><img src="https://cloud.githubusercontent.com/assets/4536249/16898033/d51451a6-4bf9-11e6-9d04-204fa37c912c.png" alt=""></p>
<p>　　下面的例子展示如何在KieContainer上注册一个KieScanner。</p>
<pre><code>Example 4.15. Registering and starting a KieScanner on a KieContainer

KieServices kieServices = KieServices.Factory.get();
ReleaseId releaseId = kieServices.newReleaseId( &quot;org.acme&quot;, &quot;myartifact&quot;, &quot;1.0-SNAPSHOT&quot; );
KieContainer kContainer = kieServices.newKieContainer( releaseId );
KieScanner kScanner = kieServices.newKieScanner( kContainer );

// Start the KieScanner polling the Maven repository every 10 seconds
kScanner.start( 10000L );
</code></pre><p>　　在这个示例中KieScanner被配置成间隔固定的时间自动运行，但它也支持通过调用scanNow()方法立即执行，如果KieScanner在Maven仓库中找到被KieContainer使用的Kie项目存在更新版本，则会自动下载新的版本，并对项目进行增量构建，在这个点上，所有在KieContainer控制下的KieBase和KieSession都会自动更新，具体而言，那些通过getKieBase（）获取的KieBase，以及它们所关联的KieSession，还有那些直接使用KieContainer.newKieSession() 获取的KieSession（实际上这些KieSession与缺省的KieBase相关联），都会更新使用新的版本，此外，从这一刻起，所有从KieContainer获取的新的KieBase以及KieSession都会使用新的项目版本。这里需要注意的是，那些已经存在的，并且是通过newKieBase（）获取的KieBase以及它们所关联的KieSession不会自动更新，这是应为通过newKieBase（）获取的KieBase不在KieContainer的直接控制下。</p>
<p>　　KieSession会自动获取设置为SNAPSHOT, version range, LATEST, 或 RELEASE的jars，对于设置固定版本的在运行状态下不会自动更新。</p>
<h5 id="4-2-3-4-Maven版本和依赖"><a href="#4-2-3-4-Maven版本和依赖" class="headerlink" title="4.2.3.4 Maven版本和依赖"></a>4.2.3.4 Maven版本和依赖</h5><p>　　Maven为应用程序提供了多种版本控制以及依赖管理的方式，模块可以使用特定版本号进行发布，也可以使用SNAPSHOT后缀，而依赖着可以指定依赖的版本范围，或者使用SNAPSHOT方式。</p>
<p>　　StackOverflow对此提供了非常好的描述，可以参阅如下链接</p>
<p><a href="http://stackoverflow.com/questions/30571/how-do-i-tell-maven-to-use-the-latest-version-of-a-dependency" target="_blank" rel="external">http://stackoverflow.com/questions/30571/how-do-i-tell-maven-to-use-the-latest-version-of-a-dependency</a></p>
<p>　　如果你总是想使用最新版本，Maven提供两个关键字（LATEST、RELEASE），你可以用来替换版本范围，但是如果这些依赖项不是你能能控制的插件和依赖，就必须格外注意，以防止下载不兼容的版本。</p>
<p>　　当你依赖插件或依赖项时，你可以使用指定版本值的LATEST和RELEASE版本，LATEST版本是构件的最后的release或snapshot版本，是最后发布到版本库的版本，而RELEASE版本是指最后发布到版本库中的非snapshot版本。但是实际软件时依赖没有版本的构件并不是最好的方式，你也许在开发过程中为了免去更新第三方程序库的版本号的麻烦而使用LATEST和RELEASE，但是当最后发布时，你的项目应该依赖指定版本的第三方库，以减少不受控的第三方库导致的版本问题。所以再说一次，使LATEST和RELEASE一定要慎重。</p>
<p>　　可以查阅Maven书籍以了解更多的Pom语法。</p>
<p><a href="http://books.sonatype.com/mvnref-book/reference/pom-relationships-sect-pom-syntax.html" target="_blank" rel="external">http://books.sonatype.com/mvnref-book/reference/pom-relationships-sect-pom-syntax.html</a></p>
<p><a href="http://books.sonatype.com/mvnref-book/reference/pom-relationships-sect-project-dependencies.html" target="_blank" rel="external">http://books.sonatype.com/mvnref-book/reference/pom-relationships-sect-project-dependencies.html</a></p>
<p>下面是一个例子，说明各种选项，在Maven仓库中， com.foo:my-foo有下列元数据。</p>
<pre><code>&lt;metadata&gt;
  &lt;groupId&gt;com.foo&lt;/groupId&gt;
  &lt;artifactId&gt;my-foo&lt;/artifactId&gt;
  &lt;version&gt;2.0.0&lt;/version&gt;
  &lt;versioning&gt;
    &lt;release&gt;1.1.1&lt;/release&gt;
　    &lt;versions&gt;
      &lt;version&gt;1.0&lt;/version&gt;
      &lt;version&gt;1.0.1&lt;/version&gt;
      &lt;version&gt;1.1&lt;/version&gt;
      &lt;version&gt;1.1.1&lt;/version&gt;
      &lt;version&gt;2.0.0&lt;/version&gt;
    &lt;/versions&gt;
    &lt;lastUpdated&gt;20090722140000&lt;/lastUpdated&gt;
  &lt;/versioning&gt;
&lt;/metadata&gt;
</code></pre><p>　　如果项目依赖是必须的，你可以设置以下的选项（其他版本范围当然也是可以的，只是展示相关的那些），使用确切的版本１.０.１</p>
<pre><code>&lt;version&gt;[1.0.1]&lt;/version&gt;
</code></pre><p>　　显式声明版本（总是解析成１.０.１，除非发生冲突时，Maven会选择匹配的版本）</p>
<pre><code>&lt;version&gt;1.0.1&lt;/version&gt;
</code></pre><p>　　声明版本范围　１.ｘ（当前解析为1.1.1）</p>
<pre><code>&lt;version&gt;[1.0.0,2.0.0)&lt;/version&gt;
</code></pre><p>　　声明版本范围为结束为开（会被解析为２.0.0）</p>
<pre><code>&lt;version&gt;[1.0.0,)&lt;/version&gt;
</code></pre><p>　　声明版本为LATEST（会被解析为2.0.0）</p>
<pre><code>&lt;version&gt;LATEST&lt;/version&gt;
</code></pre><p>　　声明版本为RELEASE（会被解析为1.1.1）</p>
<pre><code>&lt;version&gt;RELEASE&lt;/version&gt;
</code></pre><p>　　需要注意的是，你的部署操作将更新Maven元数据中的“latest”数据项，如果要更新”release”数据项，你需要在在Maven的super Pom中激活”release-profile“ ，你可以使用”-Prelease-profile” 或”-DperformRelease=true”激活它。</p>
<h5 id="4-2-3-5-设置Setting-xml和远程仓库"><a href="#4-2-3-5-设置Setting-xml和远程仓库" class="headerlink" title="4.2.3.5 设置Setting.xml和远程仓库"></a>4.2.3.5 设置Setting.xml和远程仓库</h5><p>　　Maven的Settings.xml是用来配置Maven的，具体的信息请查看Maven网站。</p>
<p><a href="http://maven.apache.org/settings.html" target="_blank" rel="external">http://maven.apache.org/settings.html</a></p>
<p>　　Settings.xml将在三个地方存在，实际中使用的是三个地方的合并。</p>
<ol>
<li>Maven的安装目录: $M2_HOME/conf/settings.xml</li>
<li>用户目录: ${user.home}/.m2/settings.xml</li>
<li>系统属性 kie.maven.settings.custom　指定的目录</li>
</ol>
<p>　　Settings.xml 用来指定远程资源库的位置。你需要激活的配置文件，指定远程资源库，通常可以使用”activeByDefault”:</p>
<pre><code>&lt;profiles&gt;
  &lt;profile&gt;
    &lt;id&gt;profile-1&lt;/id&gt;
    &lt;activation&gt;
      &lt;activeByDefault&gt;true&lt;/activeByDefault&gt;
    &lt;/activation&gt;
    ...
  &lt;/profile&gt;
&lt;/profiles&gt;
</code></pre><p>　　如果使用多个远程仓库，请查询Maven文档。</p>
<pre><code>http://maven.apache.org/guides/mini/guide-multiple-repositories.html
</code></pre><h4 id="4-2-4-运行"><a href="#4-2-4-运行" class="headerlink" title="4.2.4 运行"></a>4.2.4 运行</h4><h5 id="4-2-4-1-KieBase"><a href="#4-2-4-1-KieBase" class="headerlink" title="4.2.4.1 KieBase"></a>4.2.4.1 KieBase</h5><p>　　KieBase是应用程序存放知识定义的仓库，它包含规则、过程、函数以及类型模型。但是KieBase并不存放数据，相反session由KieBase创建出来，用于插入数据，并可能启动流程实例。KieBase可以从KieContainer中获取，前提是这个KieContainer包含定义这个KieBase的KieModule。</p>
<pre><code>Example 4.16. Getting a KieBase from a KieContainer

KieBase kBase = kContainer.getKieBase();
</code></pre><h5 id="4-2-4-2-KieSession"><a href="#4-2-4-2-KieSession" class="headerlink" title="4.2.4.2 KieSession"></a>4.2.4.2 KieSession</h5><p>　　KieSession存储运行时数据，它是从KieBase创建的。<br><img src="https://cloud.githubusercontent.com/assets/4536249/16876913/73db83c2-4ad8-11e6-8f21-2d39cadf8703.png" alt=""></p>
<pre><code>Example 4.17. Create a KieSession from a KieBase

KieSession ksession = kbase.newKieSession();
</code></pre><h5 id="4-2-4-3-KieRuntime"><a href="#4-2-4-3-KieRuntime" class="headerlink" title="4.2.4.3 KieRuntime"></a>4.2.4.3 KieRuntime</h5><h6 id="4-2-4-3-1-KieRuntime"><a href="#4-2-4-3-1-KieRuntime" class="headerlink" title="4.2.4.3.1 KieRuntime"></a>4.2.4.3.1 KieRuntime</h6><p>　　KieRuntime提供同时适用于规则和过程的方法，例如设置全局变量和注册通道（channel）（”Exit Point” 是channel的旧有的名称）<br><img src="https://cloud.githubusercontent.com/assets/4536249/16898887/9d4cec62-4c1f-11e6-8e99-d9c161bc3b20.png" alt=""></p>
<p>####### 4.2.4.3.1.1 Globals<br>　　Globals是规则引擎可以访问的命名对象，但是与facts根本的不同在于，Globals中的对象发生变化时，不会引起规则的重新计算，所以Globals适合提供静态的信息，为规则的RHS提供服务，或者用于从规则引擎中返回对象，如果你使用Globals在规则的LHS中，确保它是不可变的，至少不要指望Globals的变化会影响规则的行为。</p>
<p>　　Global必须在规则文件中定义，而且需要与Java对象关联。</p>
<pre><code>global java.util.List list
</code></pre><p>　　当Knowledge Base知道global 标识符和类型后，可以使用 ksession.setGlobal()设置global对象，在任何的session中，可以访问global对象，在DRL中访问未定义的类型或标识的global会甩出异常。</p>
<pre><code>List list = new ArrayList();
ksession.setGlobal(&quot;list&quot;, list);   
</code></pre><p>　　请务必先设置ｇlobal，再在规则的计算评估过程中使用，否则会甩出 NullPointerException。</p>
<h5 id="4-2-4-4-事件模型"><a href="#4-2-4-4-事件模型" class="headerlink" title="4.2.4.4 事件模型"></a>4.2.4.4 事件模型</h5><p>　　规则引擎提供事件功能，包括事件的激发和对象断言等，这样可以使日志和活动审核与你的程序（或规则）的主要部分分离开。　　</p>
<p>　　KieRuntime实现了两个接口，分别是RuleRuntimeEventManager和ProcessEventManager，而这两个接口又都继承于KieRuntimeEventManager接口，这里我们只讨论RuleRuntimeEventManager。</p>
<p><img src="https://cloud.githubusercontent.com/assets/4536249/16899406/2321cc80-4c35-11e6-9bb6-8c43edd1f276.png" alt=""></p>
<p>　　RuleRuntimeEventManager 允许监听器（listeners）的添加和移除，这样working memory（工作内存？）和agenda（议程？）的事件可以被监听。</p>
<p><img src="https://cloud.githubusercontent.com/assets/4536249/16899414/b9c257ae-4c35-11e6-8aef-855e861f4226.png" alt=""></p>
<p>　　下边的代码片段展示了一个简单的agenda listener如何被定义以及绑定到一个session上，它会打印matches在它们被激发后。</p>
<pre><code>Example 4.18. Adding an AgendaEventListener

ksession.addEventListener( new DefaultAgendaEventListener() {
    public void afterMatchFired(AfterMatchFiredEvent event) {
        super.afterMatchFired( event );
        System.out.println( event );
    }
});
</code></pre><p>　　drools提供DebugRuleRuntimeEventListener和DebugAgendaEventListener用以实现debug打印相关信息，比如如果你想打印所有的Working Memory事件，你可以添加如下代码添加监听器。</p>
<pre><code>Example 4.19. Adding a DebugRuleRuntimeEventListener

ksession.addEventListener( new DebugRuleRuntimeEventListener() );
</code></pre><p>　　所有的事件都实现了KieRuntimeEvent接口，通过此接口可以获取实际的KnowlegeRuntime（事件发生的源）。<br><img src="https://cloud.githubusercontent.com/assets/4536249/16899510/6a2228f6-4c39-11e6-8ee1-2cec4110828b.png" alt=""></p>
<p>　　现在系统提供如下事件类型</p>
<ol>
<li>MatchCreatedEvent</li>
<li>MatchCancelledEvent</li>
<li>BeforeMatchFiredEvent</li>
<li>AfterMatchFiredEvent</li>
<li>AgendaGroupPushedEvent</li>
<li>AgendaGroupPoppedEvent</li>
<li>ObjectInsertEvent</li>
<li>ObjectDeletedEvent</li>
<li>ObjectUpdatedEvent</li>
<li>ProcessCompletedEvent</li>
<li>ProcessNodeLeftEvent</li>
<li>ProcessNodeTriggeredEvent</li>
<li>ProcessStartEvent</li>
</ol>
<h5 id="4-2-4-5-KieRuntimeLogger"><a href="#4-2-4-5-KieRuntimeLogger" class="headerlink" title="4.2.4.5 KieRuntimeLogger"></a>4.2.4.5 KieRuntimeLogger</h5><p>　　KieRuntimeLogger 是Drools中的综合事件系统，可以用来创建程序运行的审查日志，并提供给诸如Eclipse audit viewer等工具使用。</p>
<p><img src="https://cloud.githubusercontent.com/assets/4536249/16899557/16277f1a-4c3b-11e6-80a3-00b495b3c182.png" alt=""></p>
<pre><code>Example 4.20. FileLogger

KieRuntimeLogger logger =
  KieServices.Factory.get().getLoggers().newFileLogger(ksession, &quot;logdir/mylogfile&quot;);
...
logger.close();
</code></pre><h5 id="4-2-4-6-Commands-and-the-CommandExecutor（命令及命令执行器）"><a href="#4-2-4-6-Commands-and-the-CommandExecutor（命令及命令执行器）" class="headerlink" title="4.2.4.6 Commands and the CommandExecutor（命令及命令执行器）"></a>4.2.4.6 Commands and the CommandExecutor（命令及命令执行器）</h5><p>　　Drools中的session分为有状态和无状态两种，有状态session已经讨论过了，其使用标准的KieRuntime，可以一步一步迭代运行，无状态session在KieRuntime提供的数据集上一次性执行，它可能会返回一些结果，然后session就被销毁了，禁止再次被执行，你可以把无状态session想象成引擎的函数调用，并可能返回一些结果。</p>
<p>　　两种session的基础是CommandExecutor 接口，这个接口有有状态和无状态两个扩展接口，这将返回 ExecutionResults。</p>
<p>　　Figure 4.22. CommandExecutor</p>
<p><img src="https://cloud.githubusercontent.com/assets/4536249/16899626/330c4e88-4c3d-11e6-9140-bd5074af037d.png" alt=""></p>
<p>　　Figure 4.23. ExecutionResults</p>
<p><img src="https://cloud.githubusercontent.com/assets/4536249/16899632/5da870d6-4c3d-11e6-9472-034e65238d75.png" alt=""></p>
<p>　　CommandExecutor　允许在session上执行commands，唯一的区别是无状态的session（StatelessKieSession）最后会在销毁之前执行fireAllRules()，commands可以用CommandExecutor创建，javadoc提供了CommandExecutor可以使用的Commands的全部列表。</p>
<p>　　setGlobal 和 getGlobal 这两个命令 Drools 与 jBPM 都相关。</p>
<p>　　下边的例子展示了使用setGlobal设置Global，可选的boolean参数指明是否命令的返回值ExecutionResults中是否包含设置的gloabl的值，如果为真，ExecutionResults中的global的名称会使用设置它们时的名称，字符串可以替代这个boolean，即需要替代的新名称。</p>
<pre><code>Example 4.21. Set Global Command

StatelessKieSession ksession = kbase.newStatelessKieSession();
ExecutionResults bresults = ksession.execute( CommandFactory.newSetGlobal( &quot;stilton&quot;, new Cheese( &quot;stilton&quot; ), true);
Cheese stilton = bresults.getValue( &quot;stilton&quot; );
</code></pre><p>　　允许返回一个存在的global，第二个可选字符串参数是替代的新名称。</p>
<pre><code>Example 4.22. Get Global Command

StatelessKieSession ksession = kbase.newStatelessKieSession();
ExecutionResults bresults = ksession.execute( CommandFactory.getGlobal( &quot;stilton&quot; );
Cheese stilton = bresults.getValue( &quot;stilton&quot; );
</code></pre><p>　　上面的例子是执行单个的命令，BatchExecution是指复合命令，可以创建一个命令队列，它可以逐条执行队列中的每一条命令，这意味着你可以插入一些对象、开始一个流程、调用fireAllRules或执行一个query，所有的只在一个execute(…)，这非常强大。</p>
<p>　　无状态的session(StatelessKieSession)在最后会自动执行fireAllRules()，不过眼尖的读者可能想FireAllRules命令在StatelessKieSession上执行会有什么样的结果？StatelessKieSession上允许执行FireAllRules命令，当执行完此命令后，StatelessKieSession 在最后就不会自动执行fireAllRules()了，think of using it as a sort of manual override function.</p>
<p>　　在批处理里的任何命令，如果有外部设置的标识，则会添加它的结果到返回的ExecutionResults实例中，让我们看一个简单的例子是如何工作的，这个例子包括Drools和Jbpm的命令，具体的命令在Drools和Jbpm章节中会详细的描述。</p>
<pre><code>Example 4.23. BatchExecution Command

StatelessKieSession ksession = kbase.newStatelessKieSession();

List cmds = new ArrayList();
cmds.add( CommandFactory.newInsertObject( new Cheese( &quot;stilton&quot;, 1), &quot;stilton&quot;) );
cmds.add( CommandFactory.newStartProcess( &quot;process cheeses&quot; ) );
cmds.add( CommandFactory.newQuery( &quot;cheeses&quot; ) );
ExecutionResults bresults = ksession.execute( CommandFactory.newBatchExecution( cmds ) );
Cheese stilton = ( Cheese ) bresults.getValue( &quot;stilton&quot; );
QueryResults qresults = ( QueryResults ) bresults.getValue( &quot;cheeses&quot; );
</code></pre><p>　　上面的示例中运行了多条命令，其中两条填写了ExecutionResults。query命令默认使用query name作为标识，但它也可以映射到一个不同的标识。</p>
<p>　　所有的命令都支持XML和JSON格式（使用XStream），以及JAXB格式，这些内容会在命令API中详细介绍。</p>
<h5 id="4-2-4-7-StatelessKieSession"><a href="#4-2-4-7-StatelessKieSession" class="headerlink" title="4.2.4.7 StatelessKieSession"></a>4.2.4.7 StatelessKieSession</h5><p>　　StatelessKieSession包装KieSession，但不是扩展它，它的重点在服务类型的场景，它不需要调用dispose()，无状态的session不支持迭代的插入，同时也不支持使用java代码调用fireAllRules()，调用execute() 方法等于一次性执行下面所有内容，依次是在内部创建KieSession实例，添加所有的用户数据以及执行所有的用户命令，调用fireAllRules()，最后调用dispose()。使用这种方式的主要方法是通过由 CommandExecutor接口支持的BatchExecution（Command的子接口），two convenience methods are provided for when simple object insertion is all that’s required， CommandExecutor 和 BatchExecution在它们自己的章节中详细介绍。</p>
<p><img src="https://cloud.githubusercontent.com/assets/4536249/16904948/5b246b14-4cd1-11e6-96a9-d7b80c547cd5.png" alt=""></p>
<p>　　下面简单的例子是通过方便的API是无状态的session执行给定的java集合，它会遍历java集合，每次插入一个元素（ inserting each element in turn）。</p>
<pre><code>Example 4.24. Simple StatelessKieSession execution with a Collection

StatelessKieSession ksession = kbase.newStatelessKieSession();
ksession.execute( collection );
</code></pre><p>　　如果使用单条命令完成同样的功能，则代码如下：</p>
<pre><code>Example 4.25. Simple StatelessKieSession execution with InsertElements Command

ksession.execute( CommandFactory.newInsertElements( collection ) );  
</code></pre><p>　　如果你想插入集合本身，而不是集合的单个元素，可以使用CommandFactory.newInsert(collection)方法。</p>
<p>　　CommandFactory的方法创建支持的命令，所有这一切会被XStream和BatchExecutionHelper进行编码，BatchExecutionHelper提供XML格式的详细信息，以及如何使用Drools管道自动执行 BatchExecution和ExecutionResults的编码。</p>
<p>　　StatelessKieSession支持 globals， globals的作用域包括非命令方式，以及那些具体执行的命令。Global解决下面三个问题。</p>
<p>　　1.调用StatelessKieSession的方法getGlobals()可以返回Globals实例，通过它可以访问session的globals，globals被所有的execution calls所共享。这里需要注意的是，一定要慎用可变的 globals ，这是因为 execution calls 可能在不同的线程中同时执行。</p>
<pre><code>Example 4.26. Session scoped global
StatelessKieSession ksession = kbase.newStatelessKieSession();
// Set a global hbnSession, that can be used for DB interactions in the rules.
ksession.setGlobal( &quot;hbnSession&quot;, hibernateSession );
// Execute while being able to resolve the &quot;hbnSession&quot; identifier.
ksession.execute( collection );  
</code></pre><p>　　２.使用委托（delegate）是global的另一种方式，将一个值设置在globals（使用setGlobal(String, Object)方法）中，实际上相当于在内部标识符集合添加了一个标识符以及它的值，内部的标识符比这个设置的委托标识符优先级高，如果一个内部标识符不存在，则同名的委托global标识符将被使用（前提是存在这个global）</p>
<p>　　３.The third way of resolving globals is to have execution scoped globals. Here, a Command to set a global is passed to the CommandExecutor.</p>
<p>　　CommandExecutor接口提供导出数据的能力，所有插入的facts、global以及查询结果都可以导出。</p>
<pre><code>Example 4.27. Out identifiers

// Set up a list of commands
List cmds = new ArrayList();
cmds.add( CommandFactory.newSetGlobal( &quot;list1&quot;, new ArrayList(), true ) );
cmds.add( CommandFactory.newInsert( new Person( &quot;jon&quot;, 102 ), &quot;person&quot; ) );
cmds.add( CommandFactory.newQuery( &quot;Get People&quot; &quot;getPeople&quot; );

// Execute the list
ExecutionResults results =
  ksession.execute( CommandFactory.newBatchExecution( cmds ) );

// Retrieve the ArrayList
results.getValue( &quot;list1&quot; );
// Retrieve the inserted Person fact
results.getValue( &quot;person&quot; );
// Retrieve the query as a QueryResults instance.
results.getValue( &quot;Get People&quot; );
</code></pre><h5 id="4-2-4-8-编码"><a href="#4-2-4-8-编码" class="headerlink" title="4.2.4.8 编码"></a>4.2.4.8 编码</h5><p>　　KieMarshallers用于对KieSessions进行编码和解码。</p>
<p><img src="https://cloud.githubusercontent.com/assets/4536249/16905352/52aea3ea-4cd7-11e6-95c2-dab92a026533.png" alt=""></p>
<p>　　KieMarshallers的实例可以从KieServices中获得，简单的例子如下：</p>
<pre><code>Example 4.28. Simple Marshaller Example

// ksession is the KieSession
// kbase is the KieBase
ByteArrayOutputStream baos = new ByteArrayOutputStream();
Marshaller marshaller = KieServices.Factory.get().getMarshallers().newMarshaller( kbase );
marshaller.marshall( baos, ksession );
baos.close();
</code></pre><p>　　但是，在引用用户的数据时，你需要灵活性更高的编码，可以使用 ObjectMarshallingStrategy接口来实现自己的编码器。两个这个接口的实现已经在系统中提供了，分别是 ObjectMarshallingStrategy和SerializeMarshallingStrategy，SerializeMarshallingStrategy是默认编码器，上面的代码使用的就是这个默认编码器，它只是在用户的对象实例上调用Serializable和Externalizable方法进行编解码。而IdentityMarshallingStrategy为每一个用户对象创建一个id，并将它们存储在map中，并把id写入到流中，当解码时，访问IdentityMarshallingStrategy的map，来获取对象，这意味的，如果你使用IdentityMarshallingStrategy，对于编码的对象的生命周期，它是有状态的，它会创建id并一直保持这它试图编码的所有对象的引用。下面的例子就是使用IdentityMarshallingStrategy。<br>　　（However, with marshalling, you will need more flexibility when dealing with referenced user data. To achieve this use the ObjectMarshallingStrategy interface. Two implementations are provided, but users can implement their own. The two supplied strategies are IdentityMarshallingStrategy and SerializeMarshallingStrategy. SerializeMarshallingStrategy is the default, as shown in the example above, and it just calls the Serializable or Externalizable methods on a user instance. IdentityMarshallingStrategy creates an integer id for each user object and stores them in a Map, while the id is written to the stream. When unmarshalling it accesses the IdentityMarshallingStrategy map to retrieve the instance. This means that if you use the IdentityMarshallingStrategy, it is stateful for the life of the Marshaller instance and will create ids and keep references to all objects that it attempts to marshal. Below is the code to use an Identity Marshalling Strategy.）</p>
<pre><code>ByteArrayOutputStream baos = new ByteArrayOutputStream();
KieMarshallers kMarshallers = KieServices.Factory.get().getMarshallers()
ObjectMarshallingStrategy oms = kMarshallers.newIdentityMarshallingStrategy()
Marshaller marshaller = kMarshallers.newMarshaller( kbase, new ObjectMarshallingStrategy[]{ oms } );
marshaller.marshall( baos, ksession );
baos.close();
</code></pre><p>　　在大多数情况下，单一的策略是不够用的，为了增加灵活性，可以使用 ObjectMarshallingStrategyAcceptor 接口。这样编码过程采用链条策略，在读写用户数据时，它会遍历策略，并询问这些策略是否可以对用户数据进行编码，这里有一个实现ClassFilterAcceptor，它支持用字符串来匹配类名，默认的匹配是“<em>.</em>”，即全匹配，上面例子中IdentityMarshallingStrategy就是使用的”<em>.</em>“。</p>
<p>　　假设我们要序列化除了一个给定包外的所有的类（？例子好像是序列化这个包下面的所有类），就可以使用名字匹配的方法，例子如下：</p>
<pre><code>Example 4.30. IdentityMarshallingStrategy with Acceptor

ByteArrayOutputStream baos = new ByteArrayOutputStream();
KieMarshallers kMarshallers = KieServices.Factory.get().getMarshallers();
ObjectMarshallingStrategyAcceptor identityAcceptor =   kMarshallers.newClassFilterAcceptor( new String[] { &quot;org.domain.pkg1.*&quot; } );
ObjectMarshallingStrategy identityStrategy = kMarshallers.newIdentityMarshallingStrategy( identityAcceptor );
ObjectMarshallingStrategy sms = kMarshallers.newSerializeMarshallingStrategy();
Marshaller marshaller = kMarshallers.newMarshaller( kbase,
new ObjectMarshallingStrategy[]{ identityStrategy, sms } );
marshaller.marshall( baos, ksession );
baos.close();　
</code></pre><p>　　这里需要注意的是，编码接受检查是按照提供元素的自然顺序进行的。<br>　　还需要注意的是，如果你使用一些计划（scheduled）的匹配（matches），比如你的规则使用timers或calendars，它们必须先被编码，然后才能被使用，你配置你的KieSession使用 trackable timer job factory manager。例如下面的代码：</p>
<pre><code>Example 4.31. Configuring a trackable timer job factory manager

KieSessionConfiguration ksconf = KieServices.Factory.get().newKieSessionConfiguration();
ksconf.setOption(TimerJobFactoryOption.get(&quot;trackable&quot;));
KSession ksession = kbase.newKieSession(ksconf, null);
</code></pre><h5 id="4-2-4-9-持久化和事务处理-（Persistence-and-Transactions）"><a href="#4-2-4-9-持久化和事务处理-（Persistence-and-Transactions）" class="headerlink" title="4.2.4.9 持久化和事务处理 （Persistence and Transactions）"></a>4.2.4.9 持久化和事务处理 （Persistence and Transactions）</h5><p>　　Longterm out of the box persistence with Java Persistence API (JPA) is possible with Drools，但是它需要一些Java事务处理API（JTA）的实现，对于开发环境，建议使用 Bitronix Transaction，因为它比较简单，并可以内嵌使用，对于发布的产品，建议使用JBoss Transactions。</p>
<pre><code>Example 4.32. Simple example using transactions

KieServices kieServices = KieServices.Factory.get();
Environment env = kieServices.newEnvironment();
env.set( EnvironmentName.ENTITY_MANAGER_FACTORY,Persistence.createEntityManagerFactory( &quot;emf-name&quot; ) );
env.set( EnvironmentName.TRANSACTION_MANAGER,TransactionManagerServices.getTransactionManager() );

// KieSessionConfiguration may be null, and a default will be used
KieSession ksession = kieServices.getStoreServices().newKieSession( kbase, null, env );
int sessionId = ksession.getId();

UserTransaction ut = (UserTransaction) new InitialContext().lookup( &quot;java:comp/UserTransaction&quot; );
ut.begin();
ksession.insert( data1 );
ksession.insert( data2 );
ksession.startProcess( &quot;process1&quot; );
ut.commit();
</code></pre><p>　　如果需要使用JPA，必须在环境中设置EntityManagerFactory和TransactionManager，如果发生回滚，kession的状态也会回滚，因此可能需要在其发生回滚后，继续使用它，如果要加载之前保存的KieSession，你需要使用id，例如下面的代码：</p>
<pre><code>Example 4.33. Loading a KieSession

KieSession ksession = kieServices.getStoreServices().loadKieSession( sessionId, kbase, null, env );
</code></pre><p>　　如果要开启持久化，有几个类必须添加到你的 persistence.xml中。</p>
<pre><code>Example 4.34. Configuring JPA

&lt;persistence-unit name=&quot;org.drools.persistence.jpa&quot; transaction-type=&quot;JTA&quot;&gt;
   &lt;provider&gt;org.hibernate.ejb.HibernatePersistence&lt;/provider&gt;
   &lt;jta-data-source&gt;jdbc/BitronixJTADataSource&lt;/jta-data-source&gt;
   &lt;class&gt;org.drools.persistence.info.SessionInfo&lt;/class&gt;
   &lt;class&gt;org.drools.persistence.info.WorkItemInfo&lt;/class&gt;
   &lt;properties&gt;
     &lt;property name=&quot;hibernate.dialect&quot; value=&quot;org.hibernate.dialect.H2Dialect&quot;/&gt;
     &lt;property name=&quot;hibernate.max_fetch_depth&quot; value=&quot;3&quot;/&gt;
     &lt;property name=&quot;hibernate.hbm2ddl.auto&quot; value=&quot;update&quot; /&gt;
     &lt;property name=&quot;hibernate.show_sql&quot; value=&quot;true&quot; /&gt;
     &lt;property name=&quot;hibernate.transaction.manager_lookup_class&quot;
      value=&quot;org.hibernate.transaction.BTMTransactionManagerLookup&quot; /&gt;
   &lt;/properties&gt;
&lt;/persistence-unit&gt;
</code></pre><p>　　jdbc JTA数据源必须先配置，Bitronix提供多种方法实现这个功能，它的文档会有更详细的描述。为了快速开始，下面有一个编程方式的例子。</p>
<pre><code>Example 4.35. Configuring JTA DataSource

PoolingDataSource ds = new PoolingDataSource();
ds.setUniqueName( &quot;jdbc/BitronixJTADataSource&quot; );
ds.setClassName( &quot;org.h2.jdbcx.JdbcDataSource&quot; );
ds.setMaxPoolSize( 3 );
ds.setAllowLocalTransactions( true );
ds.getDriverProperties().put( &quot;user&quot;, &quot;sa&quot; );
ds.getDriverProperties().put( &quot;password&quot;, &quot;sasa&quot; );
ds.getDriverProperties().put( &quot;URL&quot;, &quot;jdbc:h2:mem:mydb&quot; );
ds.init();
</code></pre><p>　　Bitronix提供了简单的嵌入式的JNDI服务，测试的理想选择，要使用它，将 jndi.properties 文件添加到您的 META-INF 文件夹，并向其添加以下行︰</p>
<pre><code>Example 4.36. JNDI properties

java.naming.factory.initial=bitronix.tm.jndi.BitronixInitialContextFactory
</code></pre><h4 id="4-2-5-安装部署备忘录"><a href="#4-2-5-安装部署备忘录" class="headerlink" title="4.2.5 安装部署备忘录"></a>4.2.5 安装部署备忘录</h4><p>Figure 4.26. Installation Overview</p>
<p><img src="https://cloud.githubusercontent.com/assets/4536249/16910921/1132c676-4d0e-11e6-8a11-c8a55f6db262.png" alt=""></p>
<p>Figure 4.27. Deployment Overview</p>
<p><img src="https://cloud.githubusercontent.com/assets/4536249/16910928/19fc5006-4d0e-11e6-8103-0bab5abeccc5.png" alt=""></p>
<h4 id="4-2-6-构建、部署以及使用的例子"><a href="#4-2-6-构建、部署以及使用的例子" class="headerlink" title="4.2.6 构建、部署以及使用的例子"></a>4.2.6 构建、部署以及使用的例子</h4><p>　　学习系统的方法是研究例子，“drools-examples-api”项目中有大量的例子，你可以在GitHub中找到。</p>
<p><a href="https://github.com/droolsjbpm/drools/tree/6.0.x/drools-examples-api" target="_blank" rel="external">https://github.com/droolsjbpm/drools/tree/6.0.x/drools-examples-api</a></p>
<p>　　研究例子的顺序很重要，从简单的例子（大多数选项都使用默认值），到复杂的例子，一步步研究。</p>
<p>　　The Deploy use cases shown below all involve mvn install. Remote deployment of JARs in Maven is well covered in Maven literature. Utilize refers to the initial act of loading the resources and providing access to the KIE runtimes. Where as Run refers to the act of interacting with those runtimes.</p>
<h5 id="4-2-6-1-Default-KieSession"><a href="#4-2-6-1-Default-KieSession" class="headerlink" title="4.2.6.1 Default KieSession"></a>4.2.6.1 Default KieSession</h5><p>  Project: default-kesession.</p>
<p>　　概述: 空的 kmodule.xml文件,KieModule 包含所有的资源在单一的KieBase，下面的例子展示从classpath上检索默认的KieSession。</p>
<p>　　一个空的kmodule.xml会生成单个KieBase，这个KieBase包含resources路径中的所有文件，可以是DRL，BPMN2，XLS等，单一的KieBase也包含默认的单一的KieSession，默认的意味着不需要使用它们的名称，就可以创建它们。  </p>
<pre><code>Example 4.37. Author - kmodule.xml

&lt;kmodule xmlns=&quot;http://www.drools.org/xsd/kmodule&quot;&gt; &lt;/kmodule&gt;
</code></pre><p>–</p>
<pre><code>Example 4.38. Build and Install - Maven

mvn install
</code></pre><p>　　注意：这里的xmlns=”<a href="http://www.drools.org/xsd/kmodule" target="_blank" rel="external">http://www.drools.org/xsd/kmodule</a>“　改成xmlns=”<a href="http://jboss.org/kie/6.0.0/kmodule" target="_blank" rel="external">http://jboss.org/kie/6.0.0/kmodule</a>“　才可以顺利运行，不知道其他环境是否也需要这样。</p>
<p>　　ks.getKieClasspathContainer()返回KieContainer，其包含部署到环境classpath上的KieBase，kContainer.newKieSession()创建默认的KieSession，这里需要注意的是，你不需要为了创建KieSession而查找KieBase，KieSession知道需要与那个KieBase相关联，在这个例子里使用默认的KieBase。</p>
<pre><code>Example 4.39. Utilize and Run - Java

KieServices ks = KieServices.Factory.get();
KieContainer kContainer = ks.getKieClasspathContainer();

KieSession kSession = kContainer.newKieSession();
kSession.setGlobal(&quot;out&quot;, out);
kSession.insert(new Message(&quot;Dave&quot;, &quot;Hello, HAL. Do you read me, HAL?&quot;));
kSession.fireAllRules();            
</code></pre><h5 id="4-2-6-2-命名的KieSession"><a href="#4-2-6-2-命名的KieSession" class="headerlink" title="4.2.6.2 命名的KieSession"></a>4.2.6.2 命名的KieSession</h5><p>  Project: named-kiesession.<br>　　概述：kmodule.xml有一个命名的KieBase和一个命名的KieSession，下面的例子展示从classpath上检索命名的KieSession。</p>
<p>　　kmodule.xml 生成一个名为’kbase1’的KieBase,其中包括了在resources路径中找到的所有文件，这些文件可能是DRL、BPMN2，XLS 等，一个名为‘kession1’的KieSession与这个KieBase相关联。</p>
<pre><code>Example 4.40. Author - kmodule.xml

&lt;kmodule xmlns=&quot;http://www.drools.org/xsd/kmodule&quot;&gt;
    &lt;kbase name=&quot;kbase1&quot;&gt;
        &lt;ksession name=&quot;ksession1&quot;/&gt;
    &lt;/kbase&gt;
&lt;/kmodule&gt;
</code></pre><p>-</p>
<pre><code>Example 4.41. Build and Install - Maven

mvn install
</code></pre><p>　　ks.getKieClasspathContainer()返回KieContainer，其包含部署到环境classpath上的KieBase，这回KieSession叫做’ksession1’,你不需要先获取KieBase，系统知道ksession1应该与那个KieBase相关联。</p>
<pre><code>Example 4.42. Utilize and Run - Java

KieServices ks = KieServices.Factory.get();
KieContainer kContainer = ks.getKieClasspathContainer();

KieSession kSession = kContainer.newKieSession(&quot;ksession1&quot;);
kSession.setGlobal(&quot;out&quot;, out);
kSession.insert(new Message(&quot;Dave&quot;, &quot;Hello, HAL. Do you read me, HAL?&quot;));
kSession.fireAllRules();
</code></pre><p>　　##### 4.2.6.3 KieBase Inheritence</p>
<p>　　Project: kiebase-inclusion.</p>
<p>　　概述：kmodule.xml中，一个KieBase可以包括另一个KieBase的资源（在其他的KieModule中），在这个例子中，它继承了’name-kiesession’ 例子中的named KieBase，被包含的KieBase可以在当前的KieModule中，也可以在其他pom.xml依赖的KieModule中。</p>
<p>　　kmodule.xml 生成一个名为’kbase2’的KieBase,其中包括了在resources路径中找到的所有文件，这些文件可能是DRL、BPMN2，XLS 等，而且它使用‘includes’属性继承于kbase1，所以它同时也包括KieBase ‘kbase1’的所有的资源。名为‘ksession2’的KieSession与KieBase相关联。</p>
<pre><code>Example 4.43. Author - kmodule.xml

&lt;kbase name=&quot;kbase2&quot; includes=&quot;kbase1&quot;&gt;
    &lt;ksession name=&quot;ksession2&quot;/&gt;
&lt;/kbase&gt;
</code></pre><p>　　这个例子需要前一个例子“named-kiesession”，“named-kiesession”　需要先被编译，并且被安装与Maven　本地仓库，一旦安装与本地仓库中后，就可以在这个项目中，使用Maven的<dependencies>标签声明依赖。</dependencies></p>
<pre><code>Example 4.44. Author - pom.xml

&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot;
     xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
     xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;
  &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;
  &lt;parent&gt;
    &lt;groupId&gt;org.drools&lt;/groupId&gt;
    &lt;artifactId&gt;drools-examples-api&lt;/artifactId&gt;
    &lt;version&gt;6.0.0/version&gt;
  &lt;/parent&gt;

  &lt;artifactId&gt;kiebase-inclusion&lt;/artifactId&gt;
  &lt;name&gt;Drools API examples - KieBase Inclusion&lt;/name&gt;

  &lt;dependencies&gt;
    &lt;dependency&gt;
          &lt;groupId&gt;org.drools&lt;/groupId&gt;
          &lt;artifactId&gt;drools-compiler&lt;/artifactId&gt;
    &lt;/dependency&gt;
    &lt;dependency&gt;
          &lt;groupId&gt;org.drools&lt;/groupId&gt;
          &lt;artifactId&gt;named-kiesession&lt;/artifactId&gt;
          &lt;version&gt;6.0.0&lt;/version&gt;
        &lt;/dependency&gt;
  &lt;/dependencies&gt;
&lt;/project&gt;
</code></pre><p>　　一旦’named-kiesession’被编译，并且安装于本地Maven仓库，就可以编译测试安装当前项目。</p>
<pre><code>Example 4.45. Build and Install - Maven

mvn install
</code></pre><p>　　ks.getKieClasspathContainer()返回KieContainer，其包含部署到环境classpath上的KieBase，这回KieSession的名字为’ksession2’，你不需要先获取KieBase，ksession2知道与那个KieBase相关联，需要注意的是，这里有两个规则，一个是kbase2中的规则，另一个是它继承的kbase1中的规则。</p>
<pre><code>Example 4.46. Utilize and Run - Java

KieServices ks = KieServices.Factory.get();
KieContainer kContainer = ks.getKieClasspathContainer();
KieSession kSession = kContainer.newKieSession(&quot;ksession2&quot;);
kSession.setGlobal(&quot;out&quot;, out);

kSession.insert(new Message(&quot;Dave&quot;, &quot;Hello, HAL. Do you read me, HAL?&quot;));
kSession.fireAllRules();

kSession.insert(new Message(&quot;Dave&quot;, &quot;Open the pod bay doors, HAL.&quot;));
kSession.fireAllRules();
</code></pre><h5 id="4-2-6-4-Multiple-KieBases"><a href="#4-2-6-4-Multiple-KieBases" class="headerlink" title="4.2.6.4. Multiple KieBases"></a>4.2.6.4. Multiple KieBases</h5><p>　　Project: ‘multiple-kbases.</p>
<p>　　概述：kmodule.xml可以包括多个KieBase或KieSession的声明，KieBase的packages属性可以使其选择不同目录加载资源。</p>
<p>　　kmodule.xml包换6个不同的KieBase，kbase1包含这个KieModule的所有资源，其他的几个KieBase使用packages属性各自指定了需要加载的资源路径，这里需要注意的是，路径可以使用通配符’*’，下面就是各个KieBase的例子。</p>
<pre><code>Example 4.47. Author - kmodule.xml

&lt;kmodule xmlns=&quot;http://www.drools.org/xsd/kmodule&quot;&gt;

  &lt;kbase name=&quot;kbase1&quot;&gt;
    &lt;ksession name=&quot;ksession1&quot;/&gt;
  &lt;/kbase&gt;

  &lt;kbase name=&quot;kbase2&quot; packages=&quot;org.some.pkg&quot;&gt;
    &lt;ksession name=&quot;ksession2&quot;/&gt;
  &lt;/kbase&gt;

  &lt;kbase name=&quot;kbase3&quot; includes=&quot;kbase2&quot; packages=&quot;org.some.pkg2&quot;&gt;
    &lt;ksession name=&quot;ksession3&quot;/&gt;
  &lt;/kbase&gt;

  &lt;kbase name=&quot;kbase4&quot; packages=&quot;org.some.pkg, org.other.pkg&quot;&gt;
    &lt;ksession name=&quot;ksession4&quot;/&gt;
  &lt;/kbase&gt;

  &lt;kbase name=&quot;kbase5&quot; packages=&quot;org.*&quot;&gt;
    &lt;ksession name=&quot;ksession5&quot;/&gt;
  &lt;/kbase&gt;

  &lt;kbase name=&quot;kbase6&quot; packages=&quot;org.some.*&quot;&gt;
    &lt;ksession name=&quot;ksession6&quot;/&gt;
  &lt;/kbase&gt;
&lt;/kmodule&gt;
</code></pre><p>-</p>
<pre><code>Example 4.48. Build and Install - Maven

mvn install
</code></pre><p>　　下面是一部分的例子程序，由于每个KieSession的测试方法都比较相似，所以没有全部列出来。</p>
<pre><code>Example 4.49. Utilize and Run - Java

@Test
public void testSimpleKieBase() {
    List&lt;Integer&gt; list = useKieSession(&quot;ksession1&quot;);
    // no packages imported means import everything
    assertEquals(4, list.size());
    assertTrue( list.containsAll( asList(0, 1, 2, 3) ) );
}

//.. other tests for ksession2 to ksession6 here

private List&lt;Integer&gt; useKieSession(String name) {
    KieServices ks = KieServices.Factory.get();
    KieContainer kContainer = ks.getKieClasspathContainer();
    KieSession kSession = kContainer.newKieSession(name);

    List&lt;Integer&gt; list = new ArrayList&lt;Integer&gt;();
    kSession.setGlobal(&quot;list&quot;, list);
    kSession.insert(1);
    kSession.fireAllRules();

    return list;
}
</code></pre><h5 id="4-2-6-5-KieContainer-from-KieRepository"><a href="#4-2-6-5-KieContainer-from-KieRepository" class="headerlink" title="4.2.6.5 KieContainer from KieRepository"></a>4.2.6.5 KieContainer from KieRepository</h5><p>　　Project: kcontainer-from-repository</p>
<p>　　概述：这个项目不包含kmodule.xml ，pom.xml也不依赖于其他的KieModule，而是使用java代码从Maven仓库中动态加载KieModule</p>
<p>　　pom.xml中必须添加Kie-ci依赖，并且确定在运行时中maven是可用的，并且Maven的标准settings.xml 也可以使用。</p>
<pre><code>Example 4.50. Author - pom.xml
&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;  xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;
  &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;
  &lt;parent&gt;
    &lt;groupId&gt;org.drools&lt;/groupId&gt;
    &lt;artifactId&gt;drools-examples-api&lt;/artifactId&gt;
    &lt;version&gt;6.0.0&lt;/version&gt;
  &lt;/parent&gt;
  &lt;artifactId&gt;kiecontainer-from-kierepo&lt;/artifactId&gt;
  &lt;name&gt;Drools API examples - KieContainer from KieRepo&lt;/name&gt;
  &lt;dependencies&gt;
    &lt;dependency&gt;
          &lt;groupId&gt;org.kie&lt;/groupId&gt;
          &lt;artifactId&gt;kie-ci&lt;/artifactId&gt;
    &lt;/dependency&gt;
  &lt;/dependencies&gt;
&lt;/project&gt;
</code></pre><p>-</p>
<pre><code>Example 4.51. Build and Install - Maven

mvn install
</code></pre><p>　　在上一个例子中KieContainer是从classpath中加载的，这个例子中通过ReleaseId来创建KieContainer，ReleaseId由Maven中的group id、artifact id以及version转化而来，也可以使用LATEST和SNAPSHOT版本。</p>
<pre><code>Example 4.52. Utilize and Run - Java

KieServices ks = KieServices.Factory.get();

// Install example1 in the local Maven repo before to do this
KieContainer kContainer = ks.newKieContainer(ks.newReleaseId(&quot;org.drools&quot;, &quot;named-kiesession&quot;, &quot;6.0.0-SNAPSHOT&quot;));

KieSession kSession = kContainer.newKieSession(&quot;ksession1&quot;);
kSession.setGlobal(&quot;out&quot;, out);

Object msg1 = createMessage(kContainer, &quot;Dave&quot;, &quot;Hello, HAL. Do you read me, HAL?&quot;);
kSession.insert(msg1);
kSession.fireAllRules();
</code></pre><h5 id="4-2-6-6-Default-KieSession-from-File"><a href="#4-2-6-6-Default-KieSession-from-File" class="headerlink" title="4.2.6.6. Default KieSession from File"></a>4.2.6.6. Default KieSession from File</h5><p>　　Project: default-kiesession-from-file</p>
<p>　　概述：KieModules可以直接从本地资源文件中进行加杂，加载的KieModule提供缺省的KieBase和KieSession</p>
<p>　　kmodue.xml不存在，项目“default-kiesession”必须被先编译，生成的jar文件，可以当作引用文件。</p>
<pre><code>Example 4.53. Build and Install - Maven

mvn install
</code></pre><p>　　任何的 KieModule 可以从某个资源位置加载并添加到 KieRepository中，一旦部署到KieRepository中，就可以使用ReleaseId进行引用，这里需要注意的是，Maven和kie-ci不再被需要，It will not set up a transitive dependency parent classloader.</p>
<pre><code>Example 4.54. Utilize and Run - Java

KieServices ks = KieServices.Factory.get();
KieRepository kr = ks.getRepository();

KieModule kModule = kr.addKieModule(ks.getResources().newFileSystemResource(getFile(&quot;default-kiesession&quot;)));

KieContainer kContainer = ks.newKieContainer(kModule.getReleaseId());

KieSession kSession = kContainer.newKieSession();
kSession.setGlobal(&quot;out&quot;, out);

Object msg1 = createMessage(kContainer, &quot;Dave&quot;, &quot;Hello, HAL. Do you read me, HAL?&quot;);
kSession.insert(msg1);
kSession.fireAllRules();
</code></pre><h5 id="4-2-6-7-Named-KieSession-from-File"><a href="#4-2-6-7-Named-KieSession-from-File" class="headerlink" title="4.2.6.7. Named KieSession from File"></a>4.2.6.7. Named KieSession from File</h5><p>　　Project: named-kiesession-from-file</p>
<p>　　概述：KieModules可以直接从本地资源文件中进行加杂，加载的KieModule提供命名的KieBase和KieSession</p>
<p>　　kmodue.xml不存在，项目“name-kiesession”必须被先编译，生成的jar文件，可以当作引用文件。</p>
<pre><code>Example 4.55. Build and Install - Maven

mvn install
</code></pre><p>　　任何的 KieModule 可以从某个资源位置加载并添加到 KieRepository中，一旦部署到KieRepository中，就可以使用ReleaseId进行引用，这里需要注意的是，Maven和kie-ci不再被需要，It will not set up a transitive dependency parent classloader.</p>
<pre><code>Example 4.56. Utilize and Run - Java

KieServices ks = KieServices.Factory.get();
KieRepository kr = ks.getRepository();

KieModule kModule = kr.addKieModule(ks.getResources().newFileSystemResource(getFile(&quot;named-kiesession&quot;)));

KieContainer kContainer = ks.newKieContainer(kModule.getReleaseId());

KieSession kSession = kContainer.newKieSession(&quot;ksession1&quot;);
kSession.setGlobal(&quot;out&quot;, out);

Object msg1 = createMessage(kContainer, &quot;Dave&quot;, &quot;Hello, HAL. Do you read me, HAL?&quot;);
kSession.insert(msg1);
kSession.fireAllRules();
</code></pre><h5 id="4-2-6-8-KieModule-with-Dependent-KieModule"><a href="#4-2-6-8-KieModule-with-Dependent-KieModule" class="headerlink" title="4.2.6.8. KieModule with Dependent KieModule"></a>4.2.6.8. KieModule with Dependent KieModule</h5><p>　　Project: kie-module-form-multiple-files</p>
<p>　　概述：以编程方式加载依赖的多个KieModule，不需要使用Maven。</p>
<p>　　kmodue.xml不存在，项目“name-kiesession”和“kiebase-include”必须被先编译，生成的jar文件，可以当作引用文件。</p>
<pre><code>Example 4.57. Build and Install - Maven

mvn install
</code></pre><p>-</p>
<p>　　创建两个资源。一个是主要的 KieModule ‘exRes1’，另一个用于依赖 ‘exRes2’。即使并没有使用Kie-ci和Maven 用来解决依赖关系，但你可以手动指定依赖的 KieModules。</p>
<pre><code>Example 4.58. Utilize and Run - Java

KieServices ks = KieServices.Factory.get();
KieRepository kr = ks.getRepository();

Resource ex1Res = ks.getResources().newFileSystemResource(getFile(&quot;kiebase-inclusion&quot;));
Resource ex2Res = ks.getResources().newFileSystemResource(getFile(&quot;named-kiesession&quot;));

KieModule kModule = kr.addKieModule(ex1Res, ex2Res);
KieContainer kContainer = ks.newKieContainer(kModule.getReleaseId());

KieSession kSession = kContainer.newKieSession(&quot;ksession2&quot;);
kSession.setGlobal(&quot;out&quot;, out);

Object msg1 = createMessage(kContainer, &quot;Dave&quot;, &quot;Hello, HAL. Do you read me, HAL?&quot;);
kSession.insert(msg1);
kSession.fireAllRules();

Object msg2 = createMessage(kContainer, &quot;Dave&quot;, &quot;Open the pod bay doors, HAL.&quot;);
kSession.insert(msg2);
kSession.fireAllRules();
</code></pre><h5 id="4-2-6-9-Programmaticaly-build-a-Simple-KieModule-with-Defaults"><a href="#4-2-6-9-Programmaticaly-build-a-Simple-KieModule-with-Defaults" class="headerlink" title="4.2.6.9. Programmaticaly build a Simple KieModule with Defaults"></a>4.2.6.9. Programmaticaly build a Simple KieModule with Defaults</h5><p>　　Project: kiemoduelmodel-example<br>　　概述：　可以使用程序化的方法创建KieModule，POM和model都是默认的，这是最快的方法，但是不能添加到Mave仓库中，供其他Module使用（指4.2.6.5中的方式）</p>
<pre><code>Example 4.59. Build and Install - Maven

mvn install
</code></pre><p>　　使用程序方法创建KieModule，It populates the model that represents the ReleaseId and kmodule.xml, and it adds the relevant resources. A pom.xml is generated from the ReleaseId.</p>
<pre><code>Example 4.60. Utilize and Run - Java

KieServices ks = KieServices.Factory.get();
KieRepository kr = ks.getRepository();
KieFileSystem kfs = ks.newKieFileSystem();

kfs.write(&quot;src/main/resources/org/kie/example5/HAL5.drl&quot;, getRule());

KieBuilder kb = ks.newKieBuilder(kfs);

kb.buildAll(); // kieModule is automatically deployed to KieRepository if successfully built.
if (kb.getResults().hasMessages(Level.ERROR)) {
throw new RuntimeException(&quot;Build Errors:\n&quot; + kb.getResults().toString());
}

KieContainer kContainer = ks.newKieContainer(kr.getDefaultReleaseId());

KieSession kSession = kContainer.newKieSession();
kSession.setGlobal(&quot;out&quot;, out);

kSession.insert(new Message(&quot;Dave&quot;, &quot;Hello, HAL. Do you read me, HAL?&quot;));
kSession.fireAllRules();
</code></pre><h5 id="4-2-6-10-Programmaticaly-build-a-KieModule-using-Meta-Models"><a href="#4-2-6-10-Programmaticaly-build-a-KieModule-using-Meta-Models" class="headerlink" title="4.2.6.10. Programmaticaly build a KieModule using Meta Models"></a>4.2.6.10. Programmaticaly build a KieModule using Meta Models</h5><p>　　Project: kiemoduelmodel-example</p>
<p>　　概述：使用程序创建KieModule，创建其 kmodule.xml 元模型资源。</p>
<pre><code>Example 4.61. Build and Install - Maven

mvn install
</code></pre><p>　　使用程序的方式生成 KieModule。It populates the model that represents the ReleaseId and kmodule.xml, as well as add the relevant resources. A pom.xml is generated from the ReleaseId.</p>
<pre><code>Example 4.62. Utilize and Run - Java

KieServices ks = KieServices.Factory.get();
KieFileSystem kfs = ks.newKieFileSystem();

Resource ex1Res = ks.getResources().newFileSystemResource(getFile(&quot;named-kiesession&quot;));
Resource ex2Res = ks.getResources().newFileSystemResource(getFile(&quot;kiebase-inclusion&quot;));

ReleaseId rid = ks.newReleaseId(&quot;org.drools&quot;, &quot;kiemodulemodel-example&quot;, &quot;6.0.0-SNAPSHOT&quot;);
kfs.generateAndWritePomXML(rid);

KieModuleModel kModuleModel = ks.newKieModuleModel();
kModuleModel.newKieBaseModel(&quot;kiemodulemodel&quot;)
.addInclude(&quot;kiebase1&quot;)
.addInclude(&quot;kiebase2&quot;)
.newKieSessionModel(&quot;ksession6&quot;);

kfs.writeKModuleXML(kModuleModel.toXML());
kfs.write(&quot;src/main/resources/kiemodulemodel/HAL6.drl&quot;, getRule());

KieBuilder kb = ks.newKieBuilder(kfs);
kb.setDependencies(ex1Res, ex2Res);
kb.buildAll(); // kieModule is automatically deployed to KieRepository if successfully built.
if (kb.getResults().hasMessages(Level.ERROR)) {
    throw new RuntimeException(&quot;Build Errors:\n&quot; + kb.getResults().toString());
}

KieContainer kContainer = ks.newKieContainer(rid);

KieSession kSession = kContainer.newKieSession(&quot;ksession6&quot;);
kSession.setGlobal(&quot;out&quot;, out);

Object msg1 = createMessage(kContainer, &quot;Dave&quot;, &quot;Hello, HAL. Do you read me, HAL?&quot;);
kSession.insert(msg1);
kSession.fireAllRules();

Object msg2 = createMessage(kContainer, &quot;Dave&quot;, &quot;Open the pod bay doors, HAL.&quot;);
kSession.insert(msg2);
kSession.fireAllRules();

Object msg3 = createMessage(kContainer, &quot;Dave&quot;, &quot;What&apos;s the problem?&quot;);
kSession.insert(msg3);
kSession.fireAllRules();
</code></pre><h3 id="4-3-安全性"><a href="#4-3-安全性" class="headerlink" title="4.3 安全性"></a>4.3 安全性</h3><h4 id="4-3-1-Security-Manager"><a href="#4-3-1-Security-Manager" class="headerlink" title="4.3.1 Security Manager"></a>4.3.1 Security Manager</h4><p>  KIE是一个商业行为的建模和执行引擎，使用各种各样的例如规则、流程决策表等模型抽象。</p>
<p>　　使用这些模型抽象可能来自于第三方，无论是同一公司的不同团队，还是合作公司，甚至是互联网上的匿名提供者。</p>
<p>　　规则和流程为了完成自身的任务，需要执行代码，但是有必要对它们的运行进行一定的限制，例如不能允许创建类加载器（可以用于打开系统，并进行攻击），当然也不能允许调用System.exit()。</p>
<p>　　Java平台提供了一个完善的、方便定义的安全框架，用户可以定义应用系统的安全策略，KIE平台利用这一框架，允许开发者定义用户提交的代码的安全策略，这些代码包括规则、流程、工作项等等。</p>
<h5 id="4-3-1-1-如何定义KIE的安全策略"><a href="#4-3-1-1-如何定义KIE的安全策略" class="headerlink" title="4.3.1.1 如何定义KIE的安全策略"></a>4.3.1.1 如何定义KIE的安全策略</h5><p>　　规则和流程运行时需要的权限非常有限，但引擎本身需要执行许多复杂的操作才能工作，比如创建类加载器，读取系统属性，访问文件系统等等。</p>
<p>　　一旦安全管理器被安装，它会根据定义的策略限制JVM中运行的代码，所以KIE系统定义了两个安全策略文件，一个用于引擎本身，一个用于被引擎执行的各种模型。</p>
<p>　　一种简单的方法，是通过设置环境变量，给引擎一个相对宽松运行策略，给规则和流程一个严格限制的运行环境。</p>
<p>　　关于策略文件的语法，请详见Java文档。</p>
<p>　　<a href="http://docs.oracle.com/javase/6/docs/technotes/guides/security/PolicyFiles.html#FileSyntax" target="_blank" rel="external">http://docs.oracle.com/javase/6/docs/technotes/guides/security/PolicyFiles.html#FileSyntax</a></p>
<p>　　引擎使用的宽松策略文件大致如下：</p>
<pre><code>Example 4.63. A sample engine.policy file

grant { 
    permission java.security.AllPermission;
}
</code></pre><p>　　一个规则使用的策略文件例子如下：</p>
<pre><code>Example 4.64. A sample rules.policy file
grant { 
    permission java.util.PropertyPermission &quot;*&quot;, &quot;read&quot;; 
    permission java.lang.RuntimePermission &quot;accessDeclaredMembers&quot;; 
}
</code></pre><p>　　请注意：定义规则和流程的安全策略文件与其具体功能有关，根据更能不同，可能需要访问文件系统中的文件、数据库等权限。</p>
<p>　　为了使用这些策略文件，必须将这些策略文件以参数的方式传递给JVM，这里有三个参数是必须的。</p>
<table>
<thead>
<tr>
<th style="text-align:center">参数</th>
<th style="text-align:center">意义</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">-Djava.security.manager</td>
<td style="text-align:center">打开安全管理器</td>
</tr>
<tr>
<td style="text-align:center">-Djava.security.policy=&lt; jvm_policy_file&gt;</td>
<td style="text-align:center">定义整个应用的安全策略文件，包括引擎</td>
</tr>
<tr>
<td style="text-align:center">-Dkie.security.policy=&lt; kie_policy_file&gt;</td>
<td style="text-align:center">定义规则和流程的安全策略文件</td>
</tr>
</tbody>
</table>
<p>　　例如：</p>
<pre><code>java -Djava.security.manager -Djava.security.policy=global.policy -Dkie.security.policy=rules.policy foo.bar.MyApp
</code></pre><p>　　注意：如果在容器里执行引擎，查阅你的容器文档，找到如何设置安全管理器，以及如何定义全局的安全策略。使用上面的方法定义kie安全策略。</p>
<p>　　注意：Security Manager必须进行配置，否则kie.security.policy会被忽略。</p>
<p>　　注意：安全管理器可能会对JVM的运行效率带来负面影响，对运行效率要求很高的应用可能并不适合使用安全管理器，一个替代的方法使用其他的安全方法对策略／流程进行安全检查。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://powerpiggy.github.io/2016/07/18/Drools6官方文档4/" data-id="cir0pg0om00054sksvdya2k45" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
    
<nav id="article-nav">
  
  
    <a href="/2016/07/10/Drools6官方文档1/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title"></div>
    </a>
  
</nav>

  
</article>

</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Categories</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Blog/">Blog</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/Hexo/">Hexo</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/Hexo/" style="font-size: 10px;">Hexo</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/07/">July 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2014/03/">March 2014</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2016/07/18/Drools6官方文档4/">(no title)</a>
          </li>
        
          <li>
            <a href="/2016/07/10/Drools6官方文档1/">(no title)</a>
          </li>
        
          <li>
            <a href="/2016/07/09/hello-world/">Hello World</a>
          </li>
        
          <li>
            <a href="/2014/03/03/使用Hexo搭建个人博客/">使用Hexo搭建个人博客</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2016 LiFangzhou<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>

  </div>
</body>
</html>